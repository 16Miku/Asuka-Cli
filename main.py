#!/usr/bin/env python3
# =====================================================================
# 上面这行叫做 "shebang"（井号叹号），它的作用是：
# - 在 Linux/Mac 系统中，告诉操作系统用 python3 来运行这个脚本
# - 这样可以直接运行 ./main.py 而不需要写 python main.py
# - 在 Windows 中这行会被忽略，没有影响
# =====================================================================

"""
Asuka CLI Agent - 主入口
一个基于LLM的命令行智能助手

这是一个多行字符串（docstring），放在文件开头用于描述这个模块的用途。
Python 约定用三个引号包裹多行字符串，常用于：
1. 模块说明（像这样放在文件开头）
2. 函数/类说明（放在定义之后）
3. 多行字符串变量
"""

# =====================================================================
# 导入部分 (Import Section)
# =====================================================================
# Python 中，import 用于引入其他模块的功能
# 导入语句通常放在文件开头，按以下顺序组织：
# 1. 标准库（Python 自带）
# 2. 第三方库（pip 安装的）
# 3. 本地模块（自己写的）

import argparse  # 标准库：用于解析命令行参数
                 # 例如：python main.py --help 中的 --help 就是由 argparse 处理的

import sys       # 标准库：提供系统相关功能
                 # 这里主要用 sys.exit() 来退出程序并返回错误码

from rich.console import Console  
# 第三方库导入语法：from 模块 import 类/函数
# rich 是一个终端美化库，Console 类用于打印彩色文本
# 相比普通的 print()，Console 可以输出带颜色、样式的文本

# =====================================================================
# 全局变量/常量定义
# =====================================================================
# 创建一个 Console 实例，供整个模块使用
# 这里的 console 是全局变量，但只是用于输出，不修改状态，所以是安全的
console = Console()

# 为什么要在这里创建 console？
# 1. 避免重复创建对象（性能优化）
# 2. 保持整个程序的输出风格一致


# =====================================================================
# 主函数定义
# =====================================================================
def main():
    """
    主函数 - 程序的入口点
    
    这个函数做了三件事：
    1. 解析命令行参数（用户通过命令行传入的选项）
    2. 创建 Agent 实例（初始化 AI 助手）
    3. 根据参数决定运行模式（单命令 or 交互式）
    
    为什么要有 main() 函数？
    - 将主要逻辑封装在函数中，而不是直接写在模块顶层
    - 这样可以：
      1. 更好地组织代码
      2. 方便测试（可以单独调用 main()）
      3. 避免导入时执行代码（参见文件末尾的 if __name__ == "__main__"）
    """
    
    # =================================================================
    # 第一部分：命令行参数解析
    # =================================================================
    # argparse 是 Python 标准库，用于解析命令行参数
    # 它可以：
    # 1. 定义程序接受哪些参数
    # 2. 自动生成帮助信息（--help）
    # 3. 验证参数类型和取值
    # 4. 将参数转换为 Python 对象
    
    # 创建参数解析器
    parser = argparse.ArgumentParser(
        # description: 程序描述，显示在 --help 的开头
        description="Asuka CLI Agent - 基于LLM的命令行智能助手",
        
        # formatter_class: 控制帮助文本的格式化方式
        # RawDescriptionHelpFormatter 保留 epilog 中的换行符和空格
        # 如果不设置，Python 会自动重排文本
        formatter_class=argparse.RawDescriptionHelpFormatter,
        
        # epilog: 帮助信息的结尾部分，通常放使用示例
        epilog="""
示例:
  python main.py                    # 启动交互式会话
  python main.py -p anthropic       # 使用Claude模型
  python main.py -c "列出当前目录"   # 执行单个命令
        """
    )
    
    # -----------------------------------------------------------------
    # 添加参数：-p / --provider
    # -----------------------------------------------------------------
    # add_argument() 用于定义一个命令行参数
    parser.add_argument(
        "-p", "--provider",     # 短格式和长格式，用户可以用 -p openai 或 --provider openai
        
        choices=["openai", "anthropic"],  # 限制可选值，只能是这两个之一
                                          # 如果用户输入其他值，argparse 会报错
        
        default=None,          # 默认值：如果用户没有指定，则为 None
                               # None 表示"未指定"，后续代码会从配置文件读取
        
        help="LLM提供商 (默认从配置读取)"  # 帮助文本，显示在 --help 中
    )
    
    # -----------------------------------------------------------------
    # 添加参数：-c / --command
    # -----------------------------------------------------------------
    parser.add_argument(
        "-c", "--command",
        type=str,              # 参数类型：字符串
                               # argparse 默认就是 str，这里显式写出更清晰
        
        default=None,          # 默认不指定命令（进入交互模式）
        
        help="执行单个命令后退出"
        # 这个参数允许用户执行一次性任务，例如：
        # python main.py -c "读取 README.md 文件"
        # 执行完这个命令后程序就退出，不进入交互模式
    )
    
    # -----------------------------------------------------------------
    # 添加参数：--no-confirm
    # -----------------------------------------------------------------
    parser.add_argument(
        "--no-confirm",        # 这是一个"开关"类型的参数，没有值
        
        action="store_true",   # action 定义参数的行为
                               # "store_true" 意思是：
                               # - 如果用户指定了 --no-confirm，值为 True
                               # - 如果用户没指定，值为 False
                               # 这是布尔开关的标准写法
        
        help="禁用危险操作确认"
        # 默认情况下，执行写文件、运行命令等危险操作时需要用户确认
        # 添加这个参数可以跳过确认，适合自动化脚本使用
    )
    
    # -----------------------------------------------------------------
    # 添加参数：--max-iterations
    # -----------------------------------------------------------------
    parser.add_argument(
        "--max-iterations",
        type=int,              # 参数类型：整数
                               # argparse 会自动将用户输入转换为 int
                               # 如果用户输入的不是数字，会报错
        
        default=10,            # 默认最多迭代 10 次
        
        help="最大迭代次数 (默认: 10)"
        # 这个参数控制 Agent 的最大思考循环次数
        # 防止 Agent 陷入无限循环，是一个安全机制
    )
    
    # -----------------------------------------------------------------
    # 解析命令行参数
    # -----------------------------------------------------------------
    # parse_args() 会：
    # 1. 读取 sys.argv（命令行参数列表）
    # 2. 根据上面定义的规则解析参数
    # 3. 返回一个 Namespace 对象，包含所有参数的值
    #
    # 例如，用户执行：python main.py -p openai --max-iterations 5
    # args 的值将是：Namespace(provider='openai', command=None, no_confirm=False, max_iterations=5)
    # 可以用 args.provider、args.command 等方式访问
    args = parser.parse_args()
    
    # =================================================================
    # 第二部分：导入 Agent 模块
    # =================================================================
    # 为什么在这里导入而不是在文件开头？
    # 1. 延迟导入：只有真正需要时才导入，加快启动速度
    # 2. 错误处理：如果导入失败，可以给用户友好的错误提示
    # 3. 避免循环导入：有时模块之间相互依赖，延迟导入可以解决这个问题
    
    try:
        # from agent import Agent 等价于：
        # import agent
        # Agent = agent.Agent
        # 从 agent 包（agent/ 目录）导入 Agent 类
        from agent import Agent
        
    except ImportError as e:
        # ImportError：导入失败时抛出的异常
        # 可能的原因：
        # 1. 依赖库没有安装（openai、anthropic、rich 等）
        # 2. 代码文件缺失或损坏
        # 3. Python 路径配置问题
        
        # console.print() 打印彩色文本
        # [red]...[/red] 是 rich 的标记语法，表示红色文本
        console.print(f"[red]导入错误: {e}[/red]")
        
        # [yellow]...[/yellow] 表示黄色文本，用于警告/提示
        console.print("[yellow]请确保已安装依赖: pip install -r requirements.txt[/yellow]")
        
        # sys.exit(1) 退出程序
        # 参数 1 是退出码（exit code）：
        # - 0 表示正常退出
        # - 非 0 表示异常退出，通常用 1 表示一般错误
        # 退出码可以被调用此程序的脚本捕获，用于判断是否成功
        sys.exit(1)
    
    # =================================================================
    # 第三部分：创建 Agent 实例
    # =================================================================
    # 这里又用了 try-except，因为创建 Agent 可能失败
    # 常见失败原因：
    # 1. API 密钥未配置或无效
    # 2. 网络连接问题
    # 3. 配置文件错误
    
    try:
        # 创建 Agent 实例
        # Agent() 是调用 Agent 类的构造函数（__init__ 方法）
        # 关键字参数传递：参数名=值 的形式，更清晰且顺序无关
        agent = Agent(
            provider=args.provider,           # 从命令行参数获取 LLM 提供商
            max_iterations=args.max_iterations # 从命令行参数获取最大迭代次数
        )
        
        # 如果用户指定了 --no-confirm
        if args.no_confirm:
            # 修改 Agent 实例的属性
            # require_confirmation 控制是否需要用户确认危险操作
            agent.require_confirmation = False
        
    except Exception as e:
        # Exception 是所有普通异常的基类
        # 这里捕获所有异常，提供统一的错误处理
        # 在生产代码中，可能需要区分不同类型的异常
        
        console.print(f"[red]初始化Agent失败: {e}[/red]")
        console.print("[yellow]请检查API密钥配置是否正确[/yellow]")
        sys.exit(1)
    
    # =================================================================
    # 第四部分：选择运行模式
    # =================================================================
    # 根据用户是否提供了 -c/--command 参数，决定运行模式
    
    if args.command:
        # -----------------------------------------------------------------
        # 单命令模式
        # -----------------------------------------------------------------
        # 用户通过 -c "命令" 指定了要执行的命令
        # 例如：python main.py -c "读取 config.py 文件"
        # 
        # 这种模式适合：
        # 1. 自动化脚本中调用
        # 2. 快速执行单个任务
        # 3. 与其他命令组合使用（管道等）
        
        agent.chat(args.command)
        # chat() 方法会：
        # 1. 将命令发送给 LLM
        # 2. 执行 LLM 要求的工具操作
        # 3. 返回最终结果
        # 执行完毕后，程序自然结束
        
    else:
        # -----------------------------------------------------------------
        # 交互式模式（默认）
        # -----------------------------------------------------------------
        # 用户没有指定命令，进入交互式会话
        # 可以持续对话，直到用户输入 /quit 退出
        
        agent.run_interactive()
        # run_interactive() 方法会：
        # 1. 显示欢迎信息
        # 2. 进入循环，等待用户输入
        # 3. 处理用户输入（普通消息或 /命令）
        # 4. 显示 Agent 的回复
        # 5. 重复 2-4，直到用户退出


# =========================================================================
# 程序入口点
# =========================================================================
# 这是 Python 的标准写法，用于判断当前文件是被直接运行还是被导入

if __name__ == "__main__":
    """
    __name__ 是 Python 的特殊变量，表示当前模块的名称：
    
    情况1：直接运行此文件（python main.py）
    - __name__ 的值是 "__main__"
    - 条件为 True，执行 main()
    
    情况2：被其他文件导入（import main 或 from main import xxx）
    - __name__ 的值是 "main"（模块名）
    - 条件为 False，不执行 main()
    
    为什么需要这个判断？
    1. 避免导入时执行：如果其他文件只是想导入某个函数，不希望执行整个程序
    2. 方便测试：可以单独导入并测试特定函数
    3. 代码复用：同一个文件可以既作为脚本运行，又作为模块被导入
    
    举例：
    # test.py
    from main import main  # 这里不会执行 main()，只是导入
    
    # 然后可以在需要时手动调用
    if some_condition:
        main()
    """
    main()

# =========================================================================
# 补充说明：代码执行流程
# =========================================================================
"""
当用户运行 `python main.py -p openai -c "你好"` 时，执行流程如下：

1. Python 解释器加载 main.py 文件

2. 执行导入语句：
   - import argparse
   - import sys  
   - from rich.console import Console
   
3. 执行全局代码：
   - console = Console()  # 创建 Console 实例
   
4. 定义 main 函数（此时不执行函数体）

5. 执行 if __name__ == "__main__": 判断
   - 因为是直接运行，__name__ == "__main__" 为 True
   - 调用 main()

6. 进入 main() 函数：
   a. 创建 ArgumentParser
   b. 定义各个参数
   c. 解析命令行参数，得到：
      args.provider = "openai"
      args.command = "你好"
      args.no_confirm = False
      args.max_iterations = 10
   
   d. 导入 Agent 类
   
   e. 创建 Agent 实例：
      agent = Agent(provider="openai", max_iterations=10)
   
   f. 检查 args.command 不为 None
   
   g. 执行 agent.chat("你好")
   
7. chat() 方法完成后，main() 函数返回

8. 程序结束
"""
